package lang.ast;
import beaver.*;
import java.util.ArrayList;

import java.io.ByteArrayOutputStream;
import java.io.DataOutputStream;
import java.io.IOException;
import java.util.Stack;
import java.util.zip.DeflaterOutputStream;

// This is a parser generated by NeoBeaver.
public class LangParser extends beaver.Parser {
  
	static public class SyntaxError extends RuntimeException { public SyntaxError(String msg) {super(msg);}}
	// Disable syntax error recovery
	protected void recoverFromError(Symbol token, TokenStream in) {
		throw new SyntaxError("Cannot recover from the syntax error");
	}

  public static class Terminals {
    public static final short EOF = 0;
    public static final short ID = 1;
    public static final short MINUS = 2;
    public static final short RPAR = 3;
    public static final short COMMA = 4;
    public static final short INT = 5;
    public static final short LPAR = 6;
    public static final short SEMICOLON = 7;
    public static final short NUMERAL = 8;
    public static final short WHILE = 9;
    public static final short IF = 10;
    public static final short RETURN = 11;
    public static final short PLUS = 12;
    public static final short RBRACE = 13;
    public static final short NOTEQ = 14;
    public static final short MORETHAN = 15;
    public static final short MOREEQ = 16;
    public static final short EQ = 17;
    public static final short LESSEQ = 18;
    public static final short LESSTHAN = 19;
    public static final short MOD = 20;
    public static final short DIV = 21;
    public static final short MUL = 22;
    public static final short LBRACE = 23;
    public static final short EQUALS = 24;
    public static final short ELSE = 25;

    public static final String[] NAMES = {
        "EOF",
        "ID",
        "MINUS",
        "RPAR",
        "COMMA",
        "INT",
        "LPAR",
        "SEMICOLON",
        "NUMERAL",
        "WHILE",
        "IF",
        "RETURN",
        "PLUS",
        "RBRACE",
        "NOTEQ",
        "MORETHAN",
        "MOREEQ",
        "EQ",
        "LESSEQ",
        "LESSTHAN",
        "MOD",
        "DIV",
        "MUL",
        "LBRACE",
        "EQUALS",
        "ELSE",
    };
  }

  private final Action[] actions = {
    new Action() { // [0] opt_functiondecl_list = 
      public Symbol reduce(Symbol[] _symbols, int offset) {
        return new List();
      }
    },
    new Action() { // [1] opt_functiondecl_list =  functiondecl_list
      public Symbol reduce(Symbol[] _symbols, int offset) {
        final List l = (List) _symbols[offset + 1].value;
        return l;
      }
    },
    new Action() { // [2] program =  opt_functiondecl_list
      public Symbol reduce(Symbol[] _symbols, int offset) {
        final List l = (List) _symbols[offset + 1].value;
        return new Program(l);
      }
    },
    new Action() { // [3] functiondecl_list =  functiondecl
      public Symbol reduce(Symbol[] _symbols, int offset) {
        final FunctionDecl d = (FunctionDecl) _symbols[offset + 1].value;
        return new List().add(d);
      }
    },
    new Action() { // [4] functiondecl_list =  functiondecl_list functiondecl
      public Symbol reduce(Symbol[] _symbols, int offset) {
        final List l = (List) _symbols[offset + 1].value;
        final FunctionDecl d = (FunctionDecl) _symbols[offset + 2].value;
        return l.add(d);
      }
    },
    new Action() { // [5] GOAL =  program EOF
      public Symbol reduce(Symbol[] _symbols, int offset) {
        final Program program = (Program) _symbols[offset + 1].value;
        final Symbol sym2 = _symbols[offset + 2];
        return program;
      }
    },
    new Action() { // [6] iddecl =  ID
      public Symbol reduce(Symbol[] _symbols, int offset) {
        final Symbol id = _symbols[offset + 1];
        return new IdDecl(id);
      }
    },
    new Action() { // [7] opt_param_list = 
      public Symbol reduce(Symbol[] _symbols, int offset) {
        return new List();
      }
    },
    new Action() { // [8] opt_param_list =  param_list
      public Symbol reduce(Symbol[] _symbols, int offset) {
        final List l = (List) _symbols[offset + 1].value;
        return l;
      }
    },
    new Action() { // [9] param_list =  param
      public Symbol reduce(Symbol[] _symbols, int offset) {
        final VariableDecl p = (VariableDecl) _symbols[offset + 1].value;
        return new List().add(p);
      }
    },
    new Action() { // [10] param =  INT iddecl
      public Symbol reduce(Symbol[] _symbols, int offset) {
        final Symbol INT = _symbols[offset + 1];
        final IdDecl id = (IdDecl) _symbols[offset + 2].value;
        return new VariableDecl(id, new Opt());
      }
    },
    new Action() { // [11] functiondecl =  INT iddecl LPAR opt_param_list RPAR block
      public Symbol reduce(Symbol[] _symbols, int offset) {
        final Symbol INT = _symbols[offset + 1];
        final IdDecl id = (IdDecl) _symbols[offset + 2].value;
        final Symbol LPAR = _symbols[offset + 3];
        final List pl = (List) _symbols[offset + 4].value;
        final Symbol RPAR = _symbols[offset + 5];
        final Block b = (Block) _symbols[offset + 6].value;
        return new FunctionDecl(id, pl, b);
      }
    },
    new Action() { // [12] opt_stmt_list = 
      public Symbol reduce(Symbol[] _symbols, int offset) {
        return new List();
      }
    },
    new Action() { // [13] param_list =  param_list COMMA param
      public Symbol reduce(Symbol[] _symbols, int offset) {
        final List l = (List) _symbols[offset + 1].value;
        final Symbol COMMA = _symbols[offset + 2];
        final VariableDecl p = (VariableDecl) _symbols[offset + 3].value;
        return l.add(p);
      }
    },
    new Action() { // [14] opt_stmt_list =  stmt_list
      public Symbol reduce(Symbol[] _symbols, int offset) {
        final List l = (List) _symbols[offset + 1].value;
        return l;
      }
    },
    new Action() { // [15] stmt =  while
      public Symbol reduce(Symbol[] _symbols, int offset) {
        final While w = (While) _symbols[offset + 1].value;
        return w;
      }
    },
    new Action() { // [16] stmt =  variabledecl
      public Symbol reduce(Symbol[] _symbols, int offset) {
        final VariableDecl id = (VariableDecl) _symbols[offset + 1].value;
        return id;
      }
    },
    new Action() { // [17] stmt_list =  stmt
      public Symbol reduce(Symbol[] _symbols, int offset) {
        final Stmt s = (Stmt) _symbols[offset + 1].value;
        return new List().add(s);
      }
    },
    new Action() { // [18] stmt =  if
      public Symbol reduce(Symbol[] _symbols, int offset) {
        final If s = (If) _symbols[offset + 1].value;
        return s;
      }
    },
    new Action() { // [19] block =  LBRACE opt_stmt_list RBRACE
      public Symbol reduce(Symbol[] _symbols, int offset) {
        final Symbol LBRACE = _symbols[offset + 1];
        final List l = (List) _symbols[offset + 2].value;
        final Symbol RBRACE = _symbols[offset + 3];
        return new Block(l);
      }
    },
    new Action() { // [20] stmt_list =  stmt_list stmt
      public Symbol reduce(Symbol[] _symbols, int offset) {
        final List l = (List) _symbols[offset + 1].value;
        final Stmt s = (Stmt) _symbols[offset + 2].value;
        return l.add(s);
      }
    },
    new Action() { // [21] expr =  math_expr
      public Symbol reduce(Symbol[] _symbols, int offset) {
        final Expr e = (Expr) _symbols[offset + 1].value;
        return e;
      }
    },
    new Action() { // [22] factor =  ID
      public Symbol reduce(Symbol[] _symbols, int offset) {
        final Symbol id = _symbols[offset + 1];
        return new VariableUse(id);
      }
    },
    new Action() { // [23] math_expr =  term
      public Symbol reduce(Symbol[] _symbols, int offset) {
        final Expr t = (Expr) _symbols[offset + 1].value;
        return t;
      }
    },
    new Action() { // [24] factor =  NUMERAL
      public Symbol reduce(Symbol[] _symbols, int offset) {
        final Symbol n = _symbols[offset + 1];
        return new Numeral(n);
      }
    },
    new Action() { // [25] term =  factor
      public Symbol reduce(Symbol[] _symbols, int offset) {
        final Expr f = (Expr) _symbols[offset + 1].value;
        return f;
      }
    },
    new Action() { // [26] opt_arg_list = 
      public Symbol reduce(Symbol[] _symbols, int offset) {
        return new List();
      }
    },
    new Action() { // [27] factor =  MINUS factor
      public Symbol reduce(Symbol[] _symbols, int offset) {
        final Symbol MINUS = _symbols[offset + 1];
        final Expr f = (Expr) _symbols[offset + 2].value;
        return new Neg(f);
      }
    },
    new Action() { // [28] stmt =  RETURN expr SEMICOLON
      public Symbol reduce(Symbol[] _symbols, int offset) {
        final Symbol RETURN = _symbols[offset + 1];
        final Expr e = (Expr) _symbols[offset + 2].value;
        final Symbol SEMICOLON = _symbols[offset + 3];
        return new Return(e);
      }
    },
    new Action() { // [29] opt_arg_list =  arg_list
      public Symbol reduce(Symbol[] _symbols, int offset) {
        final List l = (List) _symbols[offset + 1].value;
        return l;
      }
    },
    new Action() { // [30] arg_list =  expr
      public Symbol reduce(Symbol[] _symbols, int offset) {
        final Expr e = (Expr) _symbols[offset + 1].value;
        return new List().add(e);
      }
    },
    new Action() { // [31] variabledecl =  INT iddecl SEMICOLON
      public Symbol reduce(Symbol[] _symbols, int offset) {
        final Symbol INT = _symbols[offset + 1];
        final IdDecl id = (IdDecl) _symbols[offset + 2].value;
        final Symbol SEMICOLON = _symbols[offset + 3];
        return new VariableDecl(id, new Opt());
      }
    },
    new Action() { // [32] expr =  math_expr LESSEQ math_expr
      public Symbol reduce(Symbol[] _symbols, int offset) {
        final Expr l = (Expr) _symbols[offset + 1].value;
        final Symbol LESSEQ = _symbols[offset + 2];
        final Expr r = (Expr) _symbols[offset + 3].value;
        return new LessEq(l, r);
      }
    },
    new Action() { // [33] expr =  math_expr NOTEQ math_expr
      public Symbol reduce(Symbol[] _symbols, int offset) {
        final Expr l = (Expr) _symbols[offset + 1].value;
        final Symbol NOTEQ = _symbols[offset + 2];
        final Expr r = (Expr) _symbols[offset + 3].value;
        return new NotEq(l, r);
      }
    },
    new Action() { // [34] math_expr =  math_expr MINUS term
      public Symbol reduce(Symbol[] _symbols, int offset) {
        final Expr e = (Expr) _symbols[offset + 1].value;
        final Symbol MINUS = _symbols[offset + 2];
        final Expr t = (Expr) _symbols[offset + 3].value;
        return new Sub(e,t);
      }
    },
    new Action() { // [35] expr =  math_expr MORETHAN math_expr
      public Symbol reduce(Symbol[] _symbols, int offset) {
        final Expr l = (Expr) _symbols[offset + 1].value;
        final Symbol MORETHAN = _symbols[offset + 2];
        final Expr r = (Expr) _symbols[offset + 3].value;
        return new MoreThan(l, r);
      }
    },
    new Action() { // [36] expr =  math_expr MOREEQ math_expr
      public Symbol reduce(Symbol[] _symbols, int offset) {
        final Expr l = (Expr) _symbols[offset + 1].value;
        final Symbol MOREEQ = _symbols[offset + 2];
        final Expr r = (Expr) _symbols[offset + 3].value;
        return new MoreEq(l, r);
      }
    },
    new Action() { // [37] expr =  math_expr LESSTHAN math_expr
      public Symbol reduce(Symbol[] _symbols, int offset) {
        final Expr l = (Expr) _symbols[offset + 1].value;
        final Symbol LESSTHAN = _symbols[offset + 2];
        final Expr r = (Expr) _symbols[offset + 3].value;
        return new LessThan(l, r);
      }
    },
    new Action() { // [38] math_expr =  math_expr PLUS term
      public Symbol reduce(Symbol[] _symbols, int offset) {
        final Expr e = (Expr) _symbols[offset + 1].value;
        final Symbol PLUS = _symbols[offset + 2];
        final Expr t = (Expr) _symbols[offset + 3].value;
        return new Add(e,t);
      }
    },
    new Action() { // [39] expr =  math_expr EQ math_expr
      public Symbol reduce(Symbol[] _symbols, int offset) {
        final Expr l = (Expr) _symbols[offset + 1].value;
        final Symbol EQ = _symbols[offset + 2];
        final Expr r = (Expr) _symbols[offset + 3].value;
        return new Equals(l, r);
      }
    },
    new Action() { // [40] term =  term DIV factor
      public Symbol reduce(Symbol[] _symbols, int offset) {
        final Expr t = (Expr) _symbols[offset + 1].value;
        final Symbol DIV = _symbols[offset + 2];
        final Expr f = (Expr) _symbols[offset + 3].value;
        return new Div(t,f);
      }
    },
    new Action() { // [41] term =  term MUL factor
      public Symbol reduce(Symbol[] _symbols, int offset) {
        final Expr t = (Expr) _symbols[offset + 1].value;
        final Symbol MUL = _symbols[offset + 2];
        final Expr f = (Expr) _symbols[offset + 3].value;
        return new Mul(t,f);
      }
    },
    new Action() { // [42] term =  term MOD factor
      public Symbol reduce(Symbol[] _symbols, int offset) {
        final Expr t = (Expr) _symbols[offset + 1].value;
        final Symbol MOD = _symbols[offset + 2];
        final Expr f = (Expr) _symbols[offset + 3].value;
        return new Mod(t,f);
      }
    },
    new Action() { // [43] factor =  LPAR expr RPAR
      public Symbol reduce(Symbol[] _symbols, int offset) {
        final Symbol LPAR = _symbols[offset + 1];
        final Expr e = (Expr) _symbols[offset + 2].value;
        final Symbol RPAR = _symbols[offset + 3];
        return e;
      }
    },
    new Action() { // [44] stmt =  ID EQUALS expr SEMICOLON
      public Symbol reduce(Symbol[] _symbols, int offset) {
        final Symbol id = _symbols[offset + 1];
        final Symbol EQUALS = _symbols[offset + 2];
        final Expr e = (Expr) _symbols[offset + 3].value;
        final Symbol SEMICOLON = _symbols[offset + 4];
        return new Assign(id, e);
      }
    },
    new Action() { // [45] while =  WHILE LPAR expr RPAR block
      public Symbol reduce(Symbol[] _symbols, int offset) {
        final Symbol WHILE = _symbols[offset + 1];
        final Symbol LPAR = _symbols[offset + 2];
        final Expr cond = (Expr) _symbols[offset + 3].value;
        final Symbol RPAR = _symbols[offset + 4];
        final Block l = (Block) _symbols[offset + 5].value;
        return new While(cond,l);
      }
    },
    new Action() { // [46] while =  WHILE LPAR expr RPAR stmt
      public Symbol reduce(Symbol[] _symbols, int offset) {
        final Symbol WHILE = _symbols[offset + 1];
        final Symbol LPAR = _symbols[offset + 2];
        final Expr cond = (Expr) _symbols[offset + 3].value;
        final Symbol RPAR = _symbols[offset + 4];
        final Stmt s = (Stmt) _symbols[offset + 5].value;
        return new While(cond, new Block(new List(s)));
      }
    },
    new Action() { // [47] factor =  ID LPAR opt_arg_list RPAR
      public Symbol reduce(Symbol[] _symbols, int offset) {
        final Symbol id = _symbols[offset + 1];
        final Symbol LPAR = _symbols[offset + 2];
        final List l = (List) _symbols[offset + 3].value;
        final Symbol RPAR = _symbols[offset + 4];
        return new FunctionUse(id, l);
      }
    },
    new Action() { // [48] arg_list =  arg_list COMMA expr
      public Symbol reduce(Symbol[] _symbols, int offset) {
        final List l = (List) _symbols[offset + 1].value;
        final Symbol COMMA = _symbols[offset + 2];
        final Expr e = (Expr) _symbols[offset + 3].value;
        return l.add(e);
      }
    },
    new Action() { // [49] stmt =  ID LPAR opt_arg_list RPAR SEMICOLON
      public Symbol reduce(Symbol[] _symbols, int offset) {
        final Symbol id = _symbols[offset + 1];
        final Symbol LPAR = _symbols[offset + 2];
        final List l = (List) _symbols[offset + 3].value;
        final Symbol RPAR = _symbols[offset + 4];
        final Symbol SEMICOLON = _symbols[offset + 5];
        return new FunctionCall(id, l);
      }
    },
    new Action() { // [50] if =  IF LPAR expr RPAR block
      public Symbol reduce(Symbol[] _symbols, int offset) {
        final Symbol IF = _symbols[offset + 1];
        final Symbol LPAR = _symbols[offset + 2];
        final Expr cond = (Expr) _symbols[offset + 3].value;
        final Symbol RPAR = _symbols[offset + 4];
        final Block l = (Block) _symbols[offset + 5].value;
        return new If(cond, l, new Opt());
      }
    },
    new Action() { // [51] if =  IF LPAR expr RPAR stmt
      public Symbol reduce(Symbol[] _symbols, int offset) {
        final Symbol IF = _symbols[offset + 1];
        final Symbol LPAR = _symbols[offset + 2];
        final Expr cond = (Expr) _symbols[offset + 3].value;
        final Symbol RPAR = _symbols[offset + 4];
        final Stmt s = (Stmt) _symbols[offset + 5].value;
        return new If(cond, new Block(new List(s)), new Opt());
      }
    },
    new Action() { // [52] variabledecl =  INT iddecl EQUALS expr SEMICOLON
      public Symbol reduce(Symbol[] _symbols, int offset) {
        final Symbol INT = _symbols[offset + 1];
        final IdDecl id = (IdDecl) _symbols[offset + 2].value;
        final Symbol EQUALS = _symbols[offset + 3];
        final Expr e = (Expr) _symbols[offset + 4].value;
        final Symbol SEMICOLON = _symbols[offset + 5];
        return new VariableDecl(id, new Opt(e));
      }
    },
    new Action() { // [53] if =  IF LPAR expr RPAR block ELSE block
      public Symbol reduce(Symbol[] _symbols, int offset) {
        final Symbol IF = _symbols[offset + 1];
        final Symbol LPAR = _symbols[offset + 2];
        final Expr cond = (Expr) _symbols[offset + 3].value;
        final Symbol RPAR = _symbols[offset + 4];
        final Block l = (Block) _symbols[offset + 5].value;
        final Symbol ELSE = _symbols[offset + 6];
        final Block e = (Block) _symbols[offset + 7].value;
        return new If(cond, l, new Opt(e));
      }
    },
  };

  static final ParsingTables PARSING_TABLES = new ParsingTables(
    "U9pjMacCL4KO$hfdUffcs95jDfXX1ePnO41M4K55HLm0KLnGH9I3YIR6UF1WZ4jCFEZ5W$6" +
    "W5sECDnCFBea73vuG5LGGd466JP01L7PHiVogNhskwZUlfryLFIq7$p$V#$$ww$#wrhVqwm" +
    "Q6feH05XaCnHZKY2qOXofK8uqH68ik3CFL68uxqOGfgCTQD6AgzCG$zEx213oA6an41zhHY" +
    "cdQpjPscRRNANiBXkZo3ThUI7ihhWUmN4LMgkDjwdYxEjuXBjAkKlxg2Fj#I97iDNX0zMuz" +
    "#qGHV#kC3VGULZKRWve195UYFaR4N$szafm$FTgv82w4nrAPURVMevq$U1ZfI1hbqSvvZ7R" +
    "cd1Fdd1loM5DSuS5ndJEAE2lEEdFEzFTAIfssaxKTZmPCuYUS7g2TK#AKQz$GxCm0MZmunS" +
    "PpSW3ETBHfxqfYHg9sPYR8wImiYj#ZLgefnygiHBqfREUtg9Lgoh6SNwDMgYd7YiyryKJKI" +
    "ZNbMF5O7t5S70yz4v5#M8vX7DDUtaervLYPA$f4dyhkoySM4bTX7kPZ4UPWGJd6WyM9iWf4" +
    "79LAvnfrrB4mRgl5#KLgu9bO6DUrIx44rrgS8r83pyJ2kAqMvx3Km3EnC6whDI2VUVFaY9y" +
    "hqCxD9JDkwXTPaUYJ2wM2y$O$n#DQTKXgu9bO6BVLuXoCMgccNAnl5TdNbUBSdIYhKDQvKy" +
    "G1tEFCsI$sEpTqhpC3kC#3uxD7zqMjL5EEbIBFOh4IFbVF5RsYLxNGcwzRMA9pSyLUiLTnz" +
    "YRbY9#a1fw9XN5T6xdFiPqzOe$AtEFGjnxHepWz3fnkqQqutKavuaUfWMTYOLpNzX$FRh5R" +
    "PUvEtBS7IzJ7zMsNrC0piJ1kgyNvGMhWcLWOjzNYx9GQU2OMncsrE3ka1fw9XN5RBSxtKIl" +
    "Lb6F5v$hsKAAiGl4vvpQvDoE#YrgffXpB#JPgfPfoB6UxrC0piJ1kgyNP9hOvZ#URg9Lgoh" +
    "6ShwDMgYdtaqTOzvNEpLkffXpRpjQebMhAiUBnda9y6RLITNawTIerm$tRnc#$iz15syn8E" +
    "$TS1z74FJU5jaLxyljx7NTwCpcTzEgv4njBMCJ6MuN0D1tfVmmuTYJF5XJD3lhKZ1OLC#ra" +
    "2ckA2r83ryToaFSoxXo7TgfGpMCDiYKp9#Qz6fzsN4PYEExjoF5KWEEpfXCyE8vpfZW#u$7" +
    "PRwb21d8OYbhQuMNkcyz#6w0FHJa#uqaXhJts4aCIjPDWFEPikuI##SoRrnpuSmQ$Rnxh0z" +
    "UM#9paqxTqU3QOgo#64ICm4gCm6cCmjYpZANbjBzut#yuGxHkV5CPXlDju$ZEEpxnvSeBxr" +
    "Y2tut2$paTyxgSLdBV$EHuShtD1MyVhQ4NsTQKuFkU2ptMqKi#ZNi$A7XolzT6s3CyKiRdw" +
    "kRhOkJ1Wtyh8yRbdLQflbyLuVFRRvVnCKS5hh$O6zvdFvvmhOpjb$uxXipwNy2vWCCU3IHM" +
    "SDv$t54NRuRUfpI#OLuNoBVCyOXNn6F4YyJRnCI7VVXxYbwyKKK$C9rOJZnDF4cyHdn0xY1" +
    "D0EaCq45t4Ee8vwPU9TubFYLt4IQ2gbcWZbX7hYQU9ruZtYS#8Rk8CK3s2Q2UM4nk8PuZNY" +
    "VU8BuXUuWAG6KlC95OGcuXdYJU83uWjn47Y8b0pWPX3h2Gs4iyHRn8V4bk98q2MOyroh5dE" +
    "IPPpakMSP5yYE2TPpabsEz473AaYceX5n5hY2U8LuXtY8s8dSHJ8vOYfn1A2Sv9xYdYLu1X" +
    "odnCSH#wqN0ykKW$H$JmF8IZxxBAE7OwKznF7Y0DMx4maH$vVC1lzB5tN9othQoFnit7v2F" +
    "u5npa7vmcJhJZd5rmlSBpgjn7vZoVEDxXliD3AMqnpdf3$fKp7jQ7pbcgxl5XEAP2xMjirI" +
    "V8f5tN#PlUtxfUjB50hCOlthPb4bqAQAvJcIgNKYhNJTX1jZ4r7ZVfLguFNtXcCDMbqQjlC" +
    "U2Vp6kdN4GtQrXFJ8AyeQUPLqK#XbMYXtwZHOFbskTv27T64Qan1Hg6EVgkAPJ1PeqNPB6R" +
    "$2ybJLXe=");

  public LangParser() {
    super(PARSING_TABLES);
  }

  protected Symbol invokeReduceAction(int rule_num, int offset) {
    return actions[rule_num].reduce(_symbols, offset);
  }
}
